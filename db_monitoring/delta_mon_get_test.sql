db2 -td@

CREATE FUNCTION MONDELTA.METRIC_DELTA( CURR BIGINT,BASELINE BIGINT )
RETURNS BIGINT
LANGUAGE SQL
CONTAINS SQL
DETERMINISTIC
RETURN CASE WHEN BASELINE IS NULL
THEN CURR
WHEN BASELINE <= CURR
THEN CURR - BASELINE
ELSE
CURR + (9223372036854775807 - BASELINE)
END
@

-- blijft niet behouden bij een disconnect
CREATE GLOBAL TEMPORARY TABLE MONDELTA.TABLE_BASELINE AS
(SELECT CURRENT TIMESTAMP AS BASELINE_TIMESTAMP,
TABSCHEMA,
TABNAME,
MEMBER,
DATA_PARTITION_ID,
TABLE_SCANS,
ROWS_READ,
ROWS_INSERTED,
ROWS_UPDATED,
ROWS_DELETED,
OVERFLOW_ACCESSES,
OVERFLOW_CREATES,
PAGE_REORGS
FROM TABLE(MON_GET_TABLE('','',-1)) AS T)
DEFINITION ONLY
ON COMMIT PRESERVE ROWS
NOT LOGGED
ON ROLLBACK PRESERVE ROWS
@


CREATE PROCEDURE MONDELTA.GET_TABLE_BASELINE()
LANGUAGE SQL
BEGIN
DELETE FROM MONDELTA.TABLE_BASELINE;
INSERT INTO MONDELTA.TABLE_BASELINE
SELECT CURRENT TIMESTAMP,
TABSCHEMA,
TABNAME,
MEMBER,
DATA_PARTITION_ID,
TABLE_SCANS,
ROWS_READ,
ROWS_INSERTED,
ROWS_UPDATED,
ROWS_DELETED,
OVERFLOW_ACCESSES,
OVERFLOW_CREATES,
PAGE_REORGS
FROM TABLE(MON_GET_TABLE('','',-2)) AS T;
END
@

CREATE FUNCTION MONDELTA.GET_TABLE_DELTA(
TABSCHEMA VARCHAR(128),
TABNAME VARCHAR(128),
MEMBER INTEGER)
RETURNS TABLE (
BASELINE_TIMESTAMP TIMESTAMP,
TABSCHEMA VARCHAR(128),
TABNAME VARCHAR(128),
MEMBER SMALLINT,
TAB_TYPE VARCHAR(14),
TAB_FILE_ID BIGINT,
DATA_PARTITION_ID INTEGER,
TBSP_ID BIGINT,
INDEX_TBSP_ID BIGINT,
LONG_TBSP_ID BIGINT,
TABLE_SCANS BIGINT,
ROWS_READ BIGINT,
ROWS_INSERTED BIGINT,
ROWS_UPDATED BIGINT,
ROWS_DELETED BIGINT,
OVERFLOW_ACCESSES BIGINT,
OVERFLOW_CREATES BIGINT,
PAGE_REORGS BIGINT)
LANGUAGE SQL
NOT DETERMINISTIC
NO EXTERNAL ACTION
READS SQL DATA
RETURN 
	SELECT
		B.BASELINE_TIMESTAMP,
		A.TABSCHEMA,
		A.TABNAME,
		A.MEMBER,
		A.TAB_TYPE,
		A.TAB_FILE_ID,
		A.DATA_PARTITION_ID,
		A.TBSP_ID,
		A.INDEX_TBSP_ID,
		A.LONG_TBSP_ID,
		MONDELTA.METRIC_DELTA(A.TABLE_SCANS, B.TABLE_SCANS),
		MONDELTA.METRIC_DELTA(A.ROWS_READ, B.ROWS_READ),
		MONDELTA.METRIC_DELTA(A.ROWS_INSERTED, B.ROWS_INSERTED),
		MONDELTA.METRIC_DELTA(A.ROWS_UPDATED, B.ROWS_UPDATED),
		MONDELTA.METRIC_DELTA(A.ROWS_DELETED, B.ROWS_DELETED),
		MONDELTA.METRIC_DELTA(A.OVERFLOW_ACCESSES, B.OVERFLOW_ACCESSES),
		MONDELTA.METRIC_DELTA(A.OVERFLOW_CREATES, B.OVERFLOW_CREATES),
		MONDELTA.METRIC_DELTA(A.PAGE_REORGS, B.PAGE_REORGS)
	FROM TABLE(MON_GET_TABLE(TABSCHEMA,TABNAME,MEMBER)) A
	LEFT OUTER JOIN MONDELTA.TABLE_BASELINE B
	ON (A.TABSCHEMA = B.TABSCHEMA AND
	A.TABNAME = B.TABNAME AND
	((A.DATA_PARTITION_ID = B.DATA_PARTITION_ID) OR
	(A.DATA_PARTITION_ID IS NULL AND B.DATA_PARTITION_ID IS NULL)) AND
	A.MEMBER = B.MEMBER)
@


CREATE PROCEDURE MONDELTA.RESET_TABLE_BASELINE()
LANGUAGE SQL
BEGIN
	DELETE FROM MONDELTA.TABLE_BASELINE;
END
@

CONNECT TO SAMPLE;
CALL MONDELTA.GET_TABLE_BASELINE();
-- WAIT / RUN TESTS
-- QUERY DATA
SELECT TABLE_SCANS FROM TABLE(MONDELTA.GET_TABLE_DELTA( 'QIS','<TABLE>', -2)) AS T;

-- sort
select 
SUBSTR(STMT_TEXT, 1, 60),
TOTAL_SORTS,
SORT_OVERFLOWS,
SORT_SHRHEAP_TOP,
SORT_SHRHEAP_ALLOCATED,
SORT_HEAP_TOP,
SORT_HEAP_ALLOCATED,
SORT_CONSUMER_HEAP_TOP,
SORT_CONSUMER_SHRHEAP_TOP,
ACTIVE_SORTS,
ACTIVE_SORTS_TOP,
ACTIVE_SORT_CONSUMERS_TOP,
ACTIVE_SORT_CONSUMERS
from table(MON_GET_ACTIVITY(NULL,-1))
where SORT_OVERFLOWS > 0;



select 
TOTAL_SORTS,
SORT_OVERFLOWS,
case when TOTAL_SORTS = 0 then 0
else
	SORT_OVERFLOWS/TOTAL_SORTS*100 
end as percentage_overflows
from table (MON_GET_CONNECTION(NULL, -1));

select funcname from syscat.functions where funcname like 'MON_GET%'

